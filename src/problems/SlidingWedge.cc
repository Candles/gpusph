/*  Copyright (c) 2011-2019 INGV, EDF, UniCT, JHU

    Istituto Nazionale di Geofisica e Vulcanologia, Sezione di Catania, Italy
    Électricité de France, Paris, France
    Università di Catania, Catania, Italy
    Johns Hopkins University, Baltimore (MD), USA

    This file is part of GPUSPH. Project founders:
        Alexis Hérault, Giuseppe Bilotta, Robert A. Dalrymple,
        Eugenio Rustico, Ciro Del Negro
    For a full list of authors and project partners, consult the logs
    and the project website <https://www.gpusph.org>

    GPUSPH is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    GPUSPH is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GPUSPH.  If not, see <http://www.gnu.org/licenses/>.
 */

/*! \file Model for a tsunami generated by a submerged rigid landslide.
 * The model follows Heinrich (1992) doi:10.1061/(ASCE)0733-950X(1992)118:3(249)
 * See also Shobeyri & Ardakani (2019) doi:10.1007/s40430-019-1938-x
 *
 * This test case illustrates several features of GPUSPH, including:
 * - how to build complex geometries from the intersection and union of simpler ones;
 * - how to design a test case that can be run in both 2D and 3D (\see addSurface and addVolume);
 * - how to implement simple FSI with rigid body dynamics without Chrono
 * - usage of the new (in GPUSPH v6) moving_body_dynamics_callback()
 *   in place of the old moving_bodies_callback()
 */

#include <cmath>
#include <iostream>
#include <stdexcept>

#include "SlidingWedge.h"

// Heinrich uses a 140kg mass for the submarine landslide (H = 1)
// and a 105kg mass for the subaerial landslide (H = 0.4).
// Just for fun, we default to a mass that interpolates linearly:
// (mass - 105)/(140 - 105) = (depth - 0.4)/(1-0.4)
// mass = 105 + 35/0.6 (depth - 0.4)
static constexpr double
default_wedge_mass(double H)
{
	return 105 + 35*(H - 0.4)/0.6;
}

// Heinrich places the wedge 1cm (0.01m) below the free surface in the submarine case (H=1m),
// and right above the free surface in the subaerial case. Since the wedge is 0.5 in length,
// this means that the wedge is placed 0.1m below the slope starting corner in the latter case.
// Again, interpolating:
// (pos - 0.01)/(0.1 - 0.01) = (depth - 1)/(0.4 - 1)
// pos = 0.01 + 0.09/0.6 (1 - depth)
static constexpr double
default_initial_wedge_position(double H)
{
	return 0.01 + 0.09*(1 - H)/0.6;
}

// *** Global geometric parameters
// We define them here so that they are visible from both the constructor
// and the moving_body_dynamics_callback method
constexpr double channel_length = 20; // this is the entire length, including the slope
constexpr double channel_width = 0.55;
constexpr double channel_depth = 1.5;
constexpr double beach_angle = 15*M_PI/180; // the beach above the slope is 15°
constexpr double slope_angle = M_PI/4; // 45° for the slope TODO allow customization?

constexpr double wedge_side = 0.5;

// gage position from the intersection of the inclines
constexpr double gage_dist[] = { 3.0, 7.0, 11.0 };

SlidingWedge::SlidingWedge(GlobalData *_gdata) : Problem(_gdata),
	// *** command-line parameters
	use_ccsph(get_option("use-ccsph", true)),
	dim(get_option("dim", 3)), // number of dimensions (2 or 3)
	ppm(get_option("ppm", dim == 2 ? 64 : 32)), // particles per meter
	rho_diff(get_option("density-diffusion", ANTUONO)),
	// ** geometric parameters that must be known also in other functions
	H(get_option("water-depth", 1.0)), // Heinrich: between 0.2 and 1.2 meters water depth
	wedge_mass(get_option("wedge-mass", default_wedge_mass(H))),
	tstart(get_option("tstart", 0.0)) // no settling time by default
{
	// sanity check
	if (dim < 2 || dim > 3)
		throw std::invalid_argument("only 2D or 3D setup is supported");
	if (slope_angle < 0 || slope_angle > M_PI/2)
		throw std::invalid_argument("invalid slope angle");
	if (H <= 0 || H > 1)
		throw std::invalid_argument("water depth H must be > 0 and <= 1");

	setup_framework();

	// *** Geometric parameters

	// sanity check
	if (H >= channel_depth)
		throw std::invalid_argument("water depth must be lower than channel depth");

	// *** SPH configuration
	// This is done before constructing the domain, since some finer details are tied
	// to the resolution
	// TODO sanity check about resolution not being too coarse
	set_deltap(1.0/ppm);

	simparams()->tend = 8;

	add_writer(VTKWRITER, 0.1);

	// *** Physical parameters
	set_gravity(-9.81); // 9.81 m/s^2 in the negative vertical direction

	auto water = add_fluid(1000.0);
	set_equation_of_state(water, 7.0, NAN); // only set the polytropic constant, let the sound speed be autocomputed
	set_kinematic_visc(water, 1.0e-6);

	// *** Construct the domain

	setPositioning(PP_CORNER);
	setFillingMethod(Object::BORDER_TANGENT);

	// Heinrich's reference coordinate system has the bottom of the slope at x = 2, and the water level at z = 0.
	// Both the slope and the beach take 1m in the horizontal direction
	constexpr double slope_x = 1.0;
	const double beach_length = slope_x/cos(beach_angle);
	const double slope_length = slope_x/cos(slope_angle);
	const double slope_ht = slope_x*tan(slope_angle); // height of the slope (should be 1m)
	const double beach_ht = slope_ht + slope_x*tan(beach_angle);
	const double bottom_z = -H;

	// The geometry is set up in much the same way in 2D and 3D. We can simplify our geometry definition
	// by collecting the differences in some early definitions
	const Point origin(0, 0, 0);
	// 'up' is Y in 2D, Z in 3D
	Vector const& Up(dim == 2 ? Vector::Ydir : Vector::Zdir);
	// the cross-flow direction, around which we rotate the slopes etc, is Z in 3D and -Y in 2D
	Vector const RotDir(dim == 2 ? Vector::Zdir : -Vector::Ydir);

	// The surface geometry in 2D is the Segment, in 3D it's the Rect. They take a different number
	// of parameters, but the Rect is exactly like the Segment, plus the cross dimension of channel_width
	auto addSurface = [this]
		(GeometryType otype, FillType ftype, Point const& o, double length) {
			return this->dim == 2 ?
				this->addSegment(otype, ftype, o, length)  :
				this->addRect(otype, ftype, o, length, channel_width);
		};
	// Similarly, volumetric elements will be created as Rect in 2D and Box in 3D.
	auto addVolume = [this]
		(GeometryType otype, FillType ftype, Point const& o, double length, double depth) {
			return this->dim == 2 ?
				this->addRect(otype, ftype, o, length, depth)  :
				this->addBox(otype, ftype, o, length, channel_width, depth);
		};

	const Point beach_corner(origin + (bottom_z + beach_ht)*Up);
	const Point slope_corner(origin + (bottom_z + slope_ht)*Up + slope_x * Vector::Xdir);
	const Point bottom_corner(origin + bottom_z*Up);

	slope_dir = cos(slope_angle)*Vector::Xdir - sin(slope_angle)*Up;

	auto beach = addSurface(GT_FIXED_BOUNDARY, FT_OUTER_BORDER, beach_corner, beach_length);
	rotate(beach, RotDir, -beach_angle);
	// trim the beach particles that would fall in the slope's backwards filling
	auto beach_trim = addPlane(slope_corner, -slope_dir, FT_UNFILL);

	// add a half a dp to the length to improve filling. extra particles will be trimmed out anyway
	auto slope = addSurface(GT_FIXED_BOUNDARY, FT_OUTER_BORDER, slope_corner, slope_length + m_deltap/2);
	rotate(slope, RotDir, -slope_angle);
	setEraseOperation(slope, ET_ERASE_FLUID);
	// trim the slope particles that would fall below the bottom line
	addPlane(bottom_corner, Up, FT_UNFILL);

	// the normal to the slope will be of use to cut out unnecessary boundary particles from the domain box,
	// and to shape the fluid and wedge correctly, so let's compute it now for later usage
	auto slope_normal = sin(slope_angle)*Vector::Xdir + cos(slope_angle)*Up;

	// A significant difference between 2D and 3D is the outer domain:
	// in 2D we can limit ourselves to a bottom and an end wall,
	// in 3D we also need the side walls at least, so we build the classic domain box instead.
	// In both of these cases, though, we need information about the thickness of the walls
	// to correct some of the geometries
	double wall_thickness = getNumBoundaryLayers()*m_deltap;
	if (dim == 2) {
		// the bottom should start where the slope ends, and cover the whole remaining channel length
		// so we shift it to the right by an amount sufficient to cover the gap at the corner with the end wall
		double skip_slope = 2*slope_x;
		auto bottom = addSegment(GT_FIXED_BOUNDARY, FT_OUTER_BORDER,
			bottom_corner + (skip_slope - wall_thickness - m_deltap)*Vector::Xdir,
			channel_length - skip_slope + 2*wall_thickness + m_deltap);
		auto end_wall = addSegment(GT_FIXED_BOUNDARY, FT_OUTER_BORDER,
			bottom_corner + channel_length*Vector::Xdir, channel_depth);
		rotate(end_wall, RotDir, M_PI/2);
	} else {
		auto domain_box = addBox(GT_FIXED_BOUNDARY, FT_OUTER_BORDER, bottom_corner,
			channel_length, channel_width, channel_depth);
		// the domain box itself should not erase anything
		setEraseOperation(domain_box, ET_ERASE_NOTHING);
		// from the domain box we want to remove the top,
		// as well as anything that is below the beach and the slope.
		// The latter in particular is a bit complicated, because planes are infinite,
		// but we only want to remove up to where the slopes start.

		// Removing the top is easy:
		//addPlane(0, 0, -1, bottom_z + channel_depth, FT_UNFILL);
		trim(domain_box, addPlane(0, 0, -1, bottom_z + channel_depth, FT_UNFILL));

		// The trick we use for the underslope is to first create the intersection of two planes,
		// set this intersection to IT_SUBTRACT, and use it to trim the domain_box.
		// The intersection of the two planes should be at the slope_corner, shifted to take into account
		// the wall thickness. Since the beanch and slope have different angles,
		// we shift by the average of the two
		auto beach_normal = sin(beach_angle)*Vector::Xdir + cos(beach_angle)*Up;
		auto avg_normal = (slope_normal + beach_normal)/2;
		avg_normal.normalize();
		auto intersection_point = slope_corner - wall_thickness*avg_normal;

		auto p1 = addPlane(intersection_point, -slope_normal);
		auto p2 = addPlane(intersection_point, -beach_normal);
		trim(p1, p2);
		setIntersectionType(p1, IT_SUBTRACT);
		trim(domain_box, p1);
	}

	// Both the fluid and box will be trimmed by a plane parallel to the slope,
	// since the slope itself cannot trim them properly (not only because it's defined before,
	// but also because it's a surface, so it doesn't unfill behind itself)
	// To make the unfilling a bit less generous, we shift the plane slightly inside
	auto slope_trimming_plane = addPlane(
		slope_corner - slope_normal*m_deltap/4,
		slope_normal);

	// Next, the fluid: this can be defined as a volume spanning the space from where the slope begins
	// to where the domain box ends.
	auto fluid_vol = addVolume(GT_FLUID, FT_SOLID,
		origin + bottom_z*Up + slope_x*Vector::Xdir,
		channel_length - slope_x, H);
	trim(fluid_vol, slope_trimming_plane);
	// TODO: an alternative way to do the filling with these irregular shapes is
	// layer by layer.

	// And finally the wedge. The placement corner is the bottom left one,
	// so we need to take the corner of the slope and go down by the wedge side.
	// Additionally, per Heinrich, the initial position in the submarine case (H=1m)
	// is 1cm (0.01m) below the free surface, but it's right above the free surface
	// in the subaerial case (H=0.4). By default we interpolate, but allow users
	// to set their preference
	const double wedge_location = get_option("wedge-location", default_initial_wedge_position(H));
	const Point wedge_corner = slope_corner - wedge_side*Up +
		wedge_location*slope_dir/cos(slope_angle);

	// The wedge is defined as a GT_MOVING_BODY: its motion is prescribed by the user
	// in \see moving_bodies_callback
	// A possible alternative would be to define it as a GT_FLOATING_BODY, and let
	// its motion be controlled by Chrono, possibly with additional constraints
	// enforced through bodies_forces_callback.
	// However, in this case its motion is very simple, and there is no need to deploy
	// Chrono. We can even take the forces exherted on the wedge by the fluid into acocunt
	// by enabling force feedback on the wedge.
	// Note also that we use an FT_SOLID fill rather than an FT_INNER_BOUNDARY,
	// because we're going to define this as a box cut through the diagonal,
	// and we don't have a way to use FillIn to fill this correctly.
	// Since the wedge is quite small, a multi-layer FillIn would actually
	// fill the entire box anyway at most practical resolutions, so there isn't much of a loss
	// in doing it this way. If necessary, we can dig out a smaller copy of the wedge inside of it
	// to reduce the number of particles further, and even limit this at higher resolutions.
	auto wedge = addVolume(GT_MOVING_BODY, FT_SOLID, wedge_corner, wedge_side, wedge_side);
	trim(wedge, slope_trimming_plane);
	// the wedge should only delete fluid, not boundary too
	setEraseOperation(wedge, ET_ERASE_FLUID);
	// we're interested on the forces acting on the wedge
	enableFeedback(wedge);

	// Set the properties of the solid so that its motion can be correctly described through FSI
	// The mass is the one we computed on initialization (140kg for the H=1m case).
	setMass(wedge, wedge_mass);

	// For the barycenter, since the cross-section is a right isosceles triangle,
	// and the cendroid is just the arithmetic mean of its vertices, we can compute it easily
	// as 1/3 off each direction from the wedge placement corner
	// (remember that the placement corner is opposite the right-angle corner of the wedge,
	// from which the barycenter is 2/3 down each side)
	auto wedge_barycenter = wedge_corner + wedge_side*Vector::Xdir/3 + wedge_side*Up/3
		// in 3D, we also need to put it correctly in the middle of the cross axis
		+ (dim == 3 ? channel_width : 0)*Vector::Ydir/2;
	setCenterOfGravity(wedge, wedge_barycenter);

	// Finally, add wave gages. Note that adding gages automatically enables
	// the SURFACE_DETECTION post-processing filter.
	//
	// We can define one point per gage,
	// with the first component matching the position we want along the x axis,
	// and the second component matching the position we want alongthe y axis in 3D.
	// This works in 2D as well because the .y component in 2D is the vertical one,
	// and the vertical component of the point is ignored by wave gages
	// (since it will be replaced during computation of the water level).

	const double mid_channel_width_pos = origin(1) + channel_width/2;
	for (double g : gage_dist) {
		const Point gage_pos(slope_corner(0) + g, mid_channel_width_pos, 0);
		// add a nearest-neighbor gage
		add_gage(gage_pos, 0);
		// and a smoothing gage with the same smoothing length as the particle system
		add_gage(gage_pos, simparams()->slength);

		// additionally, in the 3D case, there are two wave gages on the first position,
		// placed 10 cm and 40cm from the wall. In Heinrich (1992) these are only
		// at the first location, we put them at all locations
		if (dim == 3) {
			const Point glazed_wall_pos(gage_pos(0), 0, 0);
			add_gage(glazed_wall_pos + 0.1*Vector::Ydir, simparams()->slength);
			add_gage(glazed_wall_pos + 0.4*Vector::Ydir, simparams()->slength);
		}
	}
}

static constexpr double const& vertical_component(double3 const& pos, int dim)
{ return dim == 2 ? pos.y : pos.z; }

void
SlidingWedge::moving_body_dynamics_callback
		( const uint index ///< sequential index of the moving body
		, ObjectPtr object ////< pointer to the moving body object
		, const double t0 ///< time at the beginning of the timestep
		, const double t1 ///< time at the end of the timestep
		, const double dt ///< timestep
		, const int step  ///< integration step (0 = predictor, 1 = corrector)
		, float3 const& force ///< force exherted on the body by the fluid
		, float3 const& torque ///< torque exherted on the body by the fluid
		, KinematicData const& initial_kdata ///< kinematic data at time t = 0
		, KinematicData const& kdata0 ///< kinematic data at time t = t0
		, KinematicData& kdata ///< kinematic body data at time t = t1 (computed by the callback)
		, AccelerateData& adata ///< acceleration at time t = t1 (computed by the callback)
		, double3& dx ///< translation to be applied at time t = t1
		, EulerParameters& dr ////< rotation to be applied at time t = t1
		)
{
	// the motion continues until the wedge reaches the end.
	// we set stopped to true when the wedge integrates up to that position,
	static bool stopped = false;
	static double stopping_z = wedge_side/3 - H;

	// The motion of the wedge is prescribed by (see also eq. (1) in Heinrich (1992))
	//
	// M dV/dt = (P + R) + Mg
	//
	// where M is the wedge mass, V its velocity, g the gravitational acceleration,
	// P the fluid pressure and R the ground reaction.
	//
	// In our case we assume smooth surfaces so the only reaction from the ground
	// is to constraint the motion to be in the slope direction.
	static const double3 fall_dir = make_double3(slope_dir);
	static const double3 gravity = make_double3(get_gravity());

	// when dividing by the mass in 2D, we should take into account the fact that
	// our forces are missing one dimension compared to the 3D case
	static const double dim_corrected_mass = wedge_mass/(dim == 2 ? channel_width : 1.0);

	// reset (default)
    dx = make_double3(0.0); // no translation
    dr.Identity(); // no rotation
	kdata.avel = make_double3(0.0); // no angular velocity
	adata.avel_dt = make_double3(0.0); // no angular acceleration

	if (t0 >= tstart && !stopped) {
		// first of all, compute the overall body force. We work in double precision
		// for higher accuracy
		double3 body_force = make_double3(force)/dim_corrected_mass + gravity;

		// project along the contrained fall direction: this is the linear acceleration
		adata.lvel_dt = dot(fall_dir, body_force)*fall_dir;

		// dx = vel*dt in step 1
		// dx = (vel + forces*dt/2)*dt in step 2:
		dx = kdata0.lvel;
		if (step == 2)
			dx += adata.lvel_dt*dt/2;
		dx *= dt;

		kdata.crot = kdata0.crot + dx;
		kdata.lvel = kdata0.lvel + adata.lvel_dt*dt;

		// avoid going past the stopping position
		double crot_bottom = vertical_component(kdata.crot, dim);
		if (crot_bottom <= stopping_z) {
			double delta = stopping_z - crot_bottom;
			dx += -delta*fall_dir;
			kdata.crot = kdata0.crot + dx;
			if (step == 2)
				stopped = true;
		}
	} else {
		adata.lvel_dt = make_double3(0.0);
		kdata.lvel = make_double3(0.0);
	}
}
