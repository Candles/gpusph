= Contributing to GPUSPH
include::docs/defines.adoc[]
v{version}

== Introduction

This document covers the basic information needed to contribute to the development of GPUSPH.
Further details can be found in the <<docs/devel-guide.adoc#,Development Guide>>.

== Methodology

:url-git-scm: https://git-scm.com/
:url-pro-git: https://git-scm.com/book/

The GPUSPH development history is tracked with {url-git-scm}[git].
Before you get started, you may want to get familiar with the `git` tool itself;
an excellent resource in this regard is the freely available {url-pro-git}[Pro Git] book.

GPUSPH follows a centralized development model with feature branches.
There is {url-github}[a main repository (hosted on GitHub)]
with reference branches (`master`, `candidate`, `next`).

The `next` branch is the main development branch.
New features should be developed in independent branches forked off the current `next` branch.
They will be merged back into the `next` branch on completion.

The `candidate` branch represent a feature-freeze release-candidate for the upcoming version of GPUSPH.
When the `next` branch is considered ready for release, it will be merged into `candidate`,
which undergoes more thorough testing and may receive appropriate bug-fixes.

When ready, the `candidate` branch is promoted to `master`, and a new GPUSPH release is tagged.
If further bugfixes are necessary, they are applied to `master` directly,
which is then merged back into `candidate` and into `next`.

== Communication

The {url-github}issues/[GitHub issue tracker] is available to submit specific issues
about building and running GPUSPH, as well as to present any feature request.

For more general discussion about GPUSPH, its use and development, please join
{url-forum}[the GPUSPH Discourse Forum].

The GPUSPH developers can also be found {url-irc}[on IRC, `#gpusph` channel on the
libera.chat network].

== Reading the source

If you wish to contribute, it's better to start by getting familiar with
the source code itself, starting from the way it's laid out on disk.

=== Repository layout

The repository top-level is structured in the following way:

`src`:: holds the main source directory;
`options`:: configuration-specific header files, generated by the configuration and build process, are stored here;
`scripts`:: holds auxiliary scripts to e.g. find the main GPU architecture or analyze/compare result files;
`docs`:: holds the documentation;
`data_files`:: created by `scripts/get-data-files`, holds the support data files for the sample test cases;
`build`,`dist`:: object files and final executables will be stored here;
`tests`:: by default, test cases will store their data in a subdirectory of this.

The `src` directory itself is structured in the following way:

`geometries`:: Classes describing geometrical objects (cubes, cones, cylinders, etc).
`writers`:: Classes implementing the `Writer` interface, to store simulation results on disk.
`integrator`:: Classes implementing the `Integrator` interface, to define the steps needed to complete an integration step.
`problem_api`:: Classes defining the test case interfaces (`Problem` API).
`problems`:: Sample test cases
`problems/user`:: User test cases
`device`:: backend-independent host/device interfaces
`cpudev`:: host/device interface definitions for the CPU backend
`cuda`:: host/device interface definitions for the CUDA backend;

NOTE: for historical reasons the `cuda` directory also includes all the device-independent
parts of the implementation of the simulation framework and its engines.
These should be moved to the `device` directory.

=== Main program flow

The program entrypoint can be found in `src/main.cc`,
which takes care of instantiating the `Problem` requested by the user at build time,
as well as the simulation engine itself (`GPUSPH`, implemented in `src/GPUSPH.cc`)
and, if appropriate, the network manager for multi-node support.

The user-specified test-case subclasses `Problem` and defines the simulation framework parameters
(SPH formulation, viscous and boundary model, etc) as well as the domain geometry and filling.

GPUSPH uses a “dumb worker” approach:
the main engine `GPUSPH` gives commands to one or more `GPUWorker`,
which each worker running in its own thread and managing a separate device (GPU).
`GPUSPH` itself takes care of all initializations and host allocation,
whereas all aspects of device management are handled by the `GPUWorker` instances which,
once initialized, enter their own main loop,
waiting for commands from `GPUSPH` and mapping these to appropriate computational kernel invocations.
The sequences of commands to be executed during a simulation are define by `Integrator` instances.
Available integrators can be found under `src/integrators`.

The computational kernel themselves are provided by the simulation framework,
which is a collection of engines taking care of separate parts of the
simulation (boundary conditions, forces computation, integration, etc) and is
instantiated by the `Problem` subclass implementing the user-specified
test-case.


